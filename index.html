<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <title>CS 4621 Final Project</title>

    <!-- Bootstrap -->
    <link href="css/bootstrap.min.css" rel="stylesheet">
    <link href="css/cs4620.css" rel="stylesheet">
    <link href="css/jquery-ui.min.css" rel="stylesheet">
    <link href="css/jquery-ui.theme.min.css" rel="stylesheet">
    <link href="css/jquery-ui.structure.min.css" rel="stylesheet">

    <!-- CUSTOM STYLESHEET -->
    <link href="css/style.css" rel="stylesheet">

    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
    <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
</head>
<body>
<div class="container">
    <h1 align="center">CS 4621 Final Project <span class="subtitle">First Person Explorer</span></h1>

    <div align="center">
        <canvas tabindex="1" id="webglCanvas" style="border: none; background-color: black;" width="800" height="600"></canvas>
    </div>

    <table class="table table-bordered" id="option-table">
        <tr>
            <td id="label" align="right"><b>Light view:</b></td>
            <td id="control"> <input id="depth" type="checkbox" /> </td>
        </tr>
        <tr>
            <td id="label" align="right"><b> Fog Density</b></td>
            <td id="control"> <input id="fogDensity" type="range" value="32" min="0" max="100"/></td>
            </td>
        </tr>
        <tr>
            <td id="control" align="right"> <button id="fullScreen" type="button">Full Screen</button></td>
        </tr>
    </table>

    <h2>Controls</h2>

    <p>
        <br><b>Click</b> on canvas for full control</br>
        <br><b>F</b> - Full screen</br>
        <br><b>W</b> - Move forward</br>
        <br><b>A</b> - Move left</br>
        <br><b>S</b> - Move backward</br>
        <br><b>D</b> - Move right</br>
        <br><b>SHIFT</b> - Sprint in any direction</br>
        <br><b>L/K</b> - Toggle light view</br>
        <br><b>Mouse</b> position and <b>Arrow keys</b> controls the view of the player</br>
    </p>

    <h2>Features Implemented</h2>

    <p>
        <br>We implemented normal mapped shading and a skybox from
        <a href="http://www.custommapmakers.org/skyboxes.php">here</a>, as well as a fog effect with Fractal Brownian Motion-based noise that moves over time.</br>
        <br>We also added smooth, FPS style movement. In addition to player movement, we added a walking/bobbing effect to simulate walking.</br>
        <br>Additionally, we implemented a simulated of a flashlight with radial falloff, something accentuated through the use of shadow mapping. Lastly, to account
        for the off-rails style of movement, we implemented mesh-based collision detection.</br>
    </p>

    <h2>Team Members</h2>

    <ul>
        <li>Adit Arya (ara93)</li>
        <li>Robert Barrett (rpb83)</li>
        <li>Ian Hoffman (ijh6)</li>
        <li>Graham Rutledge (gtr34)</li>
        <li>Paul DeVito (pid7)</li>
    </ul>

    <h2>Works Cited</h2>
    <ul>
    	<li> <a href="http://pages.cs.wisc.edu/~lizy/mrdoob-three.js-ef5f05d/examples/js/controls/PointerLockControls.js">FPS-style Mouse Movement (modified heavily)</a></li>
    	<li> <a href="http://in2gpu.com/2014/07/22/create-fog-shader/"> Exponential Fog Inspiration</a> </li>
    	<li> <a href="https://thebookofshaders.com/13/"> Fractal Brownian Noise Generation</a> </li>
    	<li> <a href="https://learnopengl.com/#!Advanced-Lighting/Shadows/Shadow-Mapping"> Shadow Mapping</a> </li>
    	<li> <a href="http://www.opengl-tutorial.org/intermediate-tutorials/tutorial-16-shadow-mapping/"> More Shadow Mapping </a></li>
    </ul>

</div>

<!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
<script src="js/jquery-3.1.1.min.js"></script>
<script src="js/jquery-ui.min.js"></script>
<script src="js/gl-matrix-min.js"></script>
<script src="js/preloadjs-0.6.2.min.js"></script>

<!-- IMPORT WEBGL BOILERPLATE -->
<script src="js/webGL_boilerplate.js"></script>

<!-- IMPORT MAZE TO BUFFER FUNCTION -->
<script src="js/maze_to_buffers.js"></script>

<!-- FULL SCREEN QUAD VERTEX SHADER -->
<script id="fullScreenQuadVertexShader" type="x-shader/x-vertex">
    attribute vec3 vert_position;
    attribute vec2 vert_texCoord;

    varying vec2 geom_texCoord;

    void main() {
        gl_Position = vec4(vert_position, 1.0);
        geom_texCoord = vert_texCoord;
    }
</script>

<script id="fullScreenQuadFragmentShader" type="x-shader/x-fragment">
    precision highp float;

    varying vec2 geom_texCoord;

    uniform sampler2D texture;
    uniform float near_plane;
    uniform float far_plane;

    float linearizeDepth(float depth) {
        float z = depth * 2.0 - 1.0;
        return (2.0 * near_plane * far_plane) / (far_plane + near_plane - z * (far_plane - near_plane));
    }

    void main() {
        float depthValue = texture2D(texture, geom_texCoord).r;
        // float coneRad = length(((geom_texCoord * 2.0) - 1.0).xy);
        vec3 linearizedDepth = vec3(linearizeDepth(depthValue) / far_plane);
        // gl_FragColor = vec4((coneRad > 0.5) ? vec3(0.0) : linearizedDepth, 1.0);
        gl_FragColor = vec4(linearizedDepth, 1.0);
    }
</script>

<!-- SHADOW VERTEX SHADER -->
<script id="shadowVertexShader" type="x-shader/x-vertex">
    attribute vec3 position;
    uniform mat4 viewMatrix;
    uniform mat4 projectionMatrix;

    void main() {
        gl_Position = projectionMatrix * viewMatrix * vec4(position, 1.0);
    }
</script>

<!-- SHADOW FRAGMENT SHADER -->
<script id="shadowFragmentShader" type="x-shader/x-fragment">
    precision lowp float;
    void main() {}
</script>

<!-- VERTEX SHADER -->
<script id="vertexShader" type="x-shader/x-vertex">
    attribute vec3 position;
    attribute vec2 uv;
    attribute float normDirection;
    attribute float textureFlag;

    // = camera.matrixWorldInverse * object.matrixWorld
    uniform mat4 modelViewMatrix;
    // = camera.projectionMatrix
    uniform mat4 projectionMatrix;
    // = camera.matrixWorldInverse
    uniform mat4 viewMatrix;
    // = inverse transpose of modelViewMatrix
    uniform mat3 normalMatrix;
    // = modelViewMatrix of flashlight
    uniform mat4 lightViewMatrix;
    // = projectionMatrix of flashlight
    uniform mat4 lightProjectionMatrix;

    uniform vec3 cameraPosition;
    uniform vec3 lightPos;

    varying vec2 vUV;
    varying vec3 vNormal;
    varying vec3 vTangent;
    varying vec3 vTangent2;
    varying vec3 vPosition;
    varying float tFlag;
    varying vec3 vLight;
    varying vec4 lightProj;
    varying vec3 camPos;

    void main() {
        tFlag = textureFlag;

        // Calculate point in eye space.
        vPosition = (modelViewMatrix * vec4(position, 1.0)).xyz;
        vLight = (modelViewMatrix * vec4(lightPos, 1.0)).xyz;

        // Calculate position UV in shadow map texture
        lightProj = lightProjectionMatrix * lightViewMatrix * vec4(position, 1.0);

        // EXTRACTING NORMAL VECTOR FROM normDirection FLAG
        int normFlag = int(normDirection);
        vec3 norm;
        vec3 tan1;
        vec3 tan2;
        if (normFlag == 0) {
            norm = vec3(0.0, 0.0, 1.0); // up
            tan1 = vec3(1.0, 0.0, 0.0);
            tan2 = vec3(0.0, 1.0, 0.0);
        } else if (normFlag == 1) {
            norm = vec3(1.0, 0.0, 0.0); // east
            tan1 = vec3(0.0, 1.0, 0.0);
            tan2 = vec3(0.0, 0.0, 1.0);
        } else if (normFlag == 2) {
            norm = vec3(0.0, 1.0, 0.0); // north
            tan1 = vec3(-1.0, 0.0, 0.0);
            tan2 = vec3(0.0, 0.0, 1.0);
        } else if (normFlag == 3) {
            norm = vec3(-1.0, 0.0, 0.0); // west
            tan1 = vec3(0.0, -1.0, 0.0);
            tan2 = vec3(0.0, 0.0, 1.0);
        } else if (normFlag == 4) {
            norm = vec3(0.0, -1.0, 0.0); // south
            tan1 = vec3(1.0, 0.0, 0.0);
            tan2 = vec3(0.0, 0.0, 1.0);
        }

        // Calculate projected point.
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);

        // We have to use the inverse transpose of the modelview matrix for the normal.
        vNormal = normalize((normalMatrix * norm).xyz);
        vTangent = normalize((normalMatrix * tan1).xyz);
        vTangent2 = normalize((normalMatrix * tan2).xyz);
        vUV = uv;
        camPos = cameraPosition;
    }
</script>

<!-- FRAGMENT SHADER -->
<script id="fragmentShader" type="x-shader/x-fragment">
    precision highp float;

    varying vec2 vUV;
    varying vec3 vNormal;
    varying vec3 vTangent;
    varying vec3 vTangent2;
    varying vec3 vPosition;
    varying float tFlag;
    varying vec3 vLight;
    varying vec4 lightProj;
    varying vec3 camPos;

    uniform sampler2D wallTexture;
    uniform sampler2D floorTexture;
    uniform sampler2D wallNormal;
    uniform sampler2D floorNormal;

    uniform float fogDensity;
    uniform vec3 rayDir;
    uniform float time;

    uniform samplerCube skyBox;

    uniform sampler2D shadowMap;

    uniform mat4 headingRot;

    //Follow noise generation functions for Fractional Brownian Noise is from https://thebookofshaders.com/13/
    float random(vec2 st, float t) {
        float t1 = floor(t / 1000.0);
        float t2 = floor(t / 1000.0) + 1.0;
        float val1 = fract(sin(dot(st.xy, vec2(12.9898*mod(t1, 1000.0), 78.233)))*43758.5453123);
        float val2 = fract(sin(dot(st.xy, vec2(12.9898*mod(t2, 1000.0), 78.233)))*43758.5453123);
        return (val1 * mod(t, 1000.0) + val2 * mod((1000.0 - t), 1000.0))/1000.0;
    	//return fract(sin(dot(st.xy, vec2(12.9898*mod(time, 100.0), 78.233)))*43758.5453123);
    }

    float noise(vec2 st) {
    	vec2 i = floor(st);
    	vec2 f  = fract(st);

    	float a = random(i, time);
    	float b = random(i + vec2(1.0, 0.0), time);
    	float c = random(i + vec2(0.0, 1.0), time);
    	float d = random(i + vec2(1.0, 1.0), time);

    	vec2 u = f * f * (3.0 - 2.0 * f); //smoothstep

    	return mix(a, b, u.x) + (c-a)*u.y * (1.0 - u.x) + (d - b) * u.x * u.y;

    }

    #define OCTAVES 6

    float fbm(vec2 st) {
    	float value = 0.0;
    	float a = 0.5;
    	float frequency = 0.;
    	vec2 shift = vec2(100);
    	//mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.5));
    	for (int i = 0; i < OCTAVES; i++){
    		value += a*noise(st);
    		//st = rot * st * 2.0 + shift;
    		st *= 2.0;
    		a *= 0.5;
    	}
    	return value;
    }

    vec4 applyFog(vec4 rgb, float distance, float fogDensity, vec2 np) {
    	distance += fbm(np);
    	//fogDensity *= random(gl_FragCoord.xy);
        float fogAmt = 1.0 - exp(-distance*fogDensity);
        //float fogAmt = 1.0 * exp(-cam.y*fogDensity) * (1.0-exp(-distance*rayDir.y*fogDensity))/rayDir.y;
        vec4 fogColor = vec4(.12, 0.28, 0.44, 0.0);
        return mix(rgb, fogColor, fogAmt);
    }

    float calculateVis(vec3 normLightProj, float bias) {
        float shadowConeDist = length(normLightProj.xy);
        normLightProj.x = (normLightProj.x * 0.5) + 0.5;
        normLightProj.y = (normLightProj.y * 0.5) + 0.5;
        normLightProj.z = (normLightProj.z * 0.5) + 0.5;
        vec4 shadowDepth = texture2D(shadowMap, normLightProj.xy);

        // Shadowing calculation
        float visibility = 1.0;
        if (shadowConeDist > 0.5) {
            visibility = max(1.0 - (4.0 * (shadowConeDist - 0.5)), 0.2);
        }
        if (normLightProj.z < 0.0) {
            visibility = 0.2;
        }
        if (shadowDepth.r < normLightProj.z - bias) {
            visibility = 0.2;
        }

        return visibility;
    }

    void main() {
        // Shadow map visibility calculation
        float dist = gl_FragCoord.z / gl_FragCoord.w; //Distance

        vec3 st = gl_FragCoord.xyz;

        //float dist = length(vPosition.xyz);
        vec3 normLightProj = lightProj.xyz / lightProj.w;
        float flashRad = 0.1;
        vec3 L = normalize(vLight + normLightProj * flashRad - vPosition.xyz);
        float bias = max(0.05 * (1.0 - dot(vNormal, L)), 0.005);
        float visibility = calculateVis(normLightProj, bias);

        float bumpiness = 1.0;
        float roughness = 0.01;
        float exposure = 1.0;

        vec4 bumpcolor = (tFlag > 0.0) ? texture2D(wallNormal, vUV) : texture2D(floorNormal, vUV);
        vec3 tangent = normalize(vTangent) * (bumpcolor.r - 0.5) * bumpiness;
        vec3 tangent2 = normalize(vTangent2) * (bumpcolor.g - 0.5) * bumpiness;
        vec3 norm = normalize(vNormal) * (bumpcolor.b - 0.5);
        vec3 N = normalize(tangent+tangent2+norm);
        vec3 V = normalize(-vPosition.xyz);

        vec4 color = (tFlag > 0.5) ? texture2D(wallTexture, vUV) : texture2D(floorTexture, vUV);
        vec4 finalColor = vec4(0.02, 0.08, 0.18, 0.0);
        float r = (length(vPosition) + 2.0)/3.0;
        r -= min(fogDensity, r - 0.4);
        vec3 H = normalize(L + V);
        vec4 Idiff = color * max(dot(N, L), 0.0);
        vec4 Ispec = vec4(1.0) * pow(max(dot(N, H), 0.0), 1.0 / roughness);
        

        finalColor = applyFog(finalColor, dist, fogDensity, st.xy);
        finalColor += visibility * vec4(1.0, 1.0, 1.0, 0.0) * (Idiff + Ispec) / (r*r);
        vec4 intermed = finalColor * exposure;

        gl_FragColor = intermed;

        // Skybox color lookup
        if (tFlag > 1.5) {
            vec3 rotatedV = (headingRot * vec4(V, 1.0)).xyz;
            gl_FragColor = applyFog(textureCube(skyBox, rotatedV), .1 , fogDensity, st.xy);
        }
    }

</script>

<!-- WEBGL SETUP -->
<script>
    // var canvas = document.getElementById("webglCanvas");
    // var width = window.innerWidth;
    // var height = window.innerHeight;
    // canvas.width = width;
    // canvas.height = height;
    var gl = initializeWebGL("webglCanvas");
    gl.getExtension("OES_texture_float");
    gl.getExtension("OES_texture_float_linear");
    gl.getExtension("WEBGL_depth_texture");
    var program = createGlslProgram(gl, "vertexShader", "fragmentShader");
    var shadowProgram = createGlslProgram(gl, "shadowVertexShader", "shadowFragmentShader");
    var fsqProgram = createGlslProgram(gl, "fullScreenQuadVertexShader", "fullScreenQuadFragmentShader");
    var fsqShape = createShape(gl,
        [
            -1.0, -1.0, 0.0,
            0.0, 0.0,
            1.0, -1.0, 0.0,
            1.0, 0.0,
            1.0, 1.0, 0.0,
            1.0, 1.0,
            -1.0, 1.0, 0.0,
            0.0, 1.0
        ],
        [
            0, 1, 2,
            0, 2, 3
        ]
    );
    var shadowFBO = gl.createFramebuffer();
    var shadowTexture = createFloatTexture(gl, 800, 600);
    var vertexBuffer = gl.createBuffer();
    var indexBuffer = gl.createBuffer();

    window.onload = function() {
        document.getElementById("webglCanvas").focus();
    }
</script>

<script>
    function getFov() {
        return (75.0 * Math.PI / 180.0);
    }

    function getEyeHeight() {
        return 0.5;
    }

    function setEyeHeight(value) {
      $("#eyeHeightSpinner").val(value);
    }

    function getMazeStrings() {
        var mazeStrings = [
            "######################################################",
            "#...#....#.....######......##.................##.....#",
            "#.#.#....#.....######......#........#..#..##..#...#..#",
            "#.#.#....#..............########....####..##..#...#..#",
            "#.#.#....##########..........###.......#..##..#...#..#",
            "#..........#...................#.......#......#.###..#",
            "#...####...#...#.....###########.......########.#....#",
            "#......#.......#...............#............#####....#",
            "#.....##########.......#.......##...........#........#",
            "#..............#########..................#####......#",
            "#...#######..........#...........#.....#.............#",
            "#....................#...........#.............#.....#",
            "#.#..#####...#####..................#..........#.....#",
            "#............#####........###.............######..####",
            "#.#......#..................#.............#....#.....#",
            "#.#......#........####......########......#....####..#",
            "#....................#......#......#......#....#.....#",
            "#.#..##..#...........#.........#####..#####...##..####",
            "#E.................###.......#........#..............#",
            "#...#....#.....######......##.................##.....#",
            "#.#.#....#.....######......#........#..#..##..#...#..#",
            "#.#.#....#..............########....####..##..#...#..#",
            "#.#.#....##########..........###.......#..##..#...#..#",
            "#..........#...................#.......#......#.###..#",
            "#...####...#...#.....###########.......########.#....#",
            "#......#.......#...............#............#####....#",
            "#.....##########.......#.......##...........#........#",
            "#..............#########..................#####......#",
            "#...#######..........#...........#.....#.............#",
            "#....................#...........#.............#.....#",
            "#.#..#####...#####..................#..........#.....#",
            "#............#####........###.............######..####",
            "#.#......#..................#.............#....#.....#",
            "#.#......#........####......########......#....####..#",
            "#....................#......#......#......#....#.....#",
            "#.#..##..#...........#.........#####..#####...##..####",
            "#..................###.......#........#..............#",
            "######################################################"
        ];
        return mazeStrings;
    }

    function createMazeFromStrings(strings) {
        var sizeY = strings.length;
        var sizeX = strings[0].length;

        var x, y;
        for(y=0;y<sizeY;y++) {
            if (strings[y].length != sizeX) {
                throw new Error("Mesh is not a rectangle!");
            }
        }

        var data = [];
        for (x = 0; x < sizeX; x++) {
            var a = [];
            for (y = 0; y < sizeY; y++) {
                a.push(null);
            }
            data.push(a);
        }

        var startPosition = null;
        var startHeading = null;
        for (x = 0; x < sizeX; x++) {
            for (y = 0; y < sizeY; y++) {
                var c = strings[sizeY - y - 1][x];
                if (c == "#") {
                    data[x][y] = 1;
                } else {
                    data[x][y] = 0;
                }

                if (c == "N" || c == "E" || c == "W" || c == "S") {
                    if (startPosition == null) {
                        if (c == "N") {
                            startHeading = Math.PI / 2;
                        } else if (c == "E") {
                            startHeading = 0.0;
                        } else if (c == "W") {
                            startHeading = Math.PI;
                        } else if (c == "S") {
                            startHeading = 3 * Math.PI / 2;
                        }
                        startPosition = [x, y];
                    } else {
                        throw new Error("There are more than one starting point!");
                    }
                }
            }
        }

        if (startPosition == null) {
            throw new Error("There is no starting point!");
        }

        for(x=0;x<sizeX;x++) {
            if (data[x][0] != 1) {
                throw new Error("Boundary is not complete!");
            }
            if (data[x][sizeY-1] != 1) {
                throw new Error("Boundary is not complete!");
            }
        }
        for(y=0;y<sizeY;y++) {
            if (data[0][y] != 1) {
                throw new Error("Boundary is not complete!");
            }
            if (data[sizeX-1][y] != 1) {
                throw new Error("Boundary is not complete!");
            }
        }

        return {
            sizeX: sizeX,
            sizeY: sizeY,
            data: data,
            startHeading: startHeading,
            startPosition: startPosition
        };
    }

    // Maze geometry vars
    var maze = null;
    var numIndices = 0;

    // Motion vars
    var heading = null;
    var targetHeading = null;
    var tilt = 0;
    var targetTilt = null;
    var maxTilt = 80.0;
    var minTilt = -60.0;
    var pos = null;
    var targetPos = null;
    var headingInt = 0;
    var animationFrames = 30;
    var keyboard = {};
    var cursor = false;
    var cursorChange = null;
    var screenPos;
    var canvas = document.getElementById("webglCanvas");
    var speedFactor = 1.0;
    var bob = 0.005;
    var t = 0;

    // Light movement test
    var lightPos = [1, 1, 0.5];
    var lightDir = [1, 0];
    var lightFocus = [1, 1];
    var lightSpeed = 0.025;
    var lightPath = [[1, 1], [10, 1], [10, 8], [1, 8]];
    var lightDirs = [[0, -1], [1, 0], [0, 1], [-1, 0]];
    var lightFocuses = [[1, 1], [-1, 1], [-1, -1], [1, -1]];
    var numPathPoints = 4;
    var currLightTarget = 1;
    var pos_offset = [0, 0, 0];
    var light_offset = [0, 0, 0];

    function moveLight() {
        lightPos = [pos[0] + 0.5 + Math.cos(heading[0]) * 0.1 + Math.sin(heading[0]) * 0.2, pos[1] + 0.5 + Math.sin(heading[0]) * 0.1 - Math.cos(heading[0]) * 0.2, pos[2] - 0.1];
        var lightPitch = (heading[1]);// + -Math.PI/3.0)/2.0
        lightFocus = [lightPos[0] + Math.cos(heading[0]) * Math.cos(lightPitch), lightPos[1] + Math.sin(heading[0]) * Math.cos(lightPitch), lightPos[2] + Math.sin(lightPitch)];
        lightFocus[0] += light_offset[0] * 0.05;
        lightFocus[1] += light_offset[1] * 0.05;
        lightFocus[2] += light_offset[2] * 0.05;
    }

    var collisionBuff = {
        vertexBuffer: [],
		indexBuffer: []
    }

    function updateMaze() {
        maze = createMazeFromStrings(getMazeStrings());
        var buffers = mazeToBuffers(maze);
        numIndices = buffers.indexBuffer.length;

        // initialize collision buffer
        collisionBuff = buffers;

        // update the collision buffer
        collisionBuff = buffers;

        // Moving vertex position array into vertexBuffer
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(buffers.vertexBuffer), gl.STATIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);

        // Moving triangle index data into indexBuffer
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(buffers.indexBuffer), gl.STATIC_DRAW);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

        // Update position and heading when maze changes
        // heading = [maze.startHeading, Math.sin()];
        heading = [maze.startHeading, 0];
        targetHeading = maze.startHeading;
        pos = [maze.startPosition[0], maze.startPosition[1], getEyeHeight()];
        targetPos = maze.startPosition;
        headingInt = Math.round(maze.startHeading / (Math.PI / 2));
        cursor = false;
        canvas = document.getElementById("webglCanvas");
    }

    updateMaze();
    // $("#updateMazeButton").click(updateMaze);

    $("#fullScreen").click(fullScreen);


    //Toggles fullscreen for canvas
    function fullScreen() {
      //var canvas = document.getElementById("webglCanvas");

      if(canvas.webkitRequestFullScreen) {
        canvas.webkitRequestFullScreen();
        document.getElementById("webglCanvas").focus();
      }
      else {
        canvas.mozRequestFullScreen();
        document.getElementById("webglCanvas").focus();
      }
    }

    //Toggles whether or not cursor is shown
    function toggleCursor() {
      //var canvas = document.getElementById("webglCanvas");
      if(cursor) {
        canvas.style.cursor = "none";
      }
      else {
        canvas.style.cursor = "default";
      }
    }

    //Catches keyDown events
    function keyDown(event) {
      keyboard[event.keyCode] = true;
    }

    //Catches keyUp events
    function keyUp(event) {
      keyboard[event.keyCode] = false;
    }

    //Catches mouseMove events
    function mouseMove(event) {
        //from http://pages.cs.wisc.edu/~lizy/mrdoob-three.js-ef5f05d/examples/js/controls/PointerLockControls.js
        var movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
        var movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;
        cursorChange = [movementX * -0.002, movementY * -0.002];
        if(cursorChange[1] >= 0.05) { cursorChange[1] = 0.05}
        if(cursorChange[1] <= -0.05) { cursorChange[1] = -.05}
        var headY = heading[1] + cursorChange[1];
        if (cursorChange[1] > 0.0) {
            if (headY >= (Math.PI / 3)) {
                headY = Math.PI / 3;
            }
        } else if (cursorChange[1] < 0.0 && (headY <= -Math.PI / 3)) {
            headY = -Math.PI / 3;
        }
        heading[1] = headY;
        if(cursorChange[0] >= 0.05) { cursorChange[0] = 0.05}
        if(cursorChange[0] <= -0.05) { cursorChange[0] = -.05}
        heading[0] += cursorChange[0];
        if (heading[0] >= 2.0 * Math.PI) {
            heading[0] -= 2.0 * Math.PI;
        } else if (heading[0] < 0.0) {
            heading[0] += 2.0 * Math.PI;
        }
    }

    var debuggedYet = false;

    function debugCollisions(i,verts,inds) {
        if(debuggedYet) return;
        console.log("Index " + i + ": " + inds[i]);
        console.log("Vertex " + inds[i] + " X: " + verts[inds[i] * 7]);
        console.log("Vertex " + inds[i] + " Y: " + verts[inds[i] * 7 + 1]);
        console.log("Vertex " + inds[i] + " Z: " + verts[inds[i] * 7 + 2]);
        console.log("Index " + (i + 1) + ": " + inds[i + 1]);
        console.log("Vertex " + inds[i + 1] + " X: " + verts[inds[i + 1] * 7]);
        console.log("Vertex " + inds[i + 1] + " Y: " + verts[inds[i + 1] * 7 + 1]);
        console.log("Vertex " + inds[i + 1] + " Z: " + verts[inds[i + 1] * 7 + 2]);
        console.log("Index " + (i + 2) + ": " + inds[i + 2]);
        console.log("Vertex " + inds[i + 2] + " X: " + verts[inds[i + 2] * 7]);
        console.log("Vertex " + inds[i + 2] + " Y: " + verts[inds[i + 2] * 7 + 1]);
        console.log("Vertex " + inds[i + 2] + " Z: " + verts[inds[i + 2] * 7 + 2]);
        if (i == inds.length - 3) {
            debuggedYet = true;

        }
    }

    function detectCollision(x,y,z,direction,normal) {
        var verts = collisionBuff.vertexBuffer;
        var inds = collisionBuff.indexBuffer;

        var threshold = 0.14;

        var camMaxX = x + threshold + 0.5;
        var camMinX = x - threshold + 0.5;
        var camMaxY = y + threshold + 0.5;
        var camMinY = y - threshold + 0.5;
        var camMaxZ = z + threshold;
        var camMinZ = z - threshold;

        // for each trangle
        for (var i = 0; i < inds.length; i += 3) {
            // find max x and y
            // debugCollisions(i,verts,inds);
            var maxX = Math.max(verts[inds[i]*7], Math.max(verts[inds[i + 1]*7], verts[inds[i + 2]*7]));
            var minX = Math.min(verts[inds[i]*7], Math.min(verts[inds[i + 1]*7], verts[inds[i + 2]*7]));
            var maxY = Math.max(verts[inds[i]*7 + 1], Math.max(verts[inds[i + 1]*7 + 1], verts[inds[i + 2]*7 + 1]));
            var minY = Math.min(verts[inds[i]*7 + 1], Math.min(verts[inds[i + 1]*7 + 1], verts[inds[i + 2]*7 + 1]));
            var maxZ = Math.max(verts[inds[i]*7 + 2], Math.max(verts[inds[i + 1]*7 + 2], verts[inds[i + 2]*7 + 2]));
            var minZ = Math.min(verts[inds[i]*7 + 2], Math.min(verts[inds[i + 1]*7 + 2], verts[inds[i + 2]*7 + 2]));

            if (camMaxX > minX && camMinX < maxX && camMaxY > minY && camMinY < maxY && camMaxZ > minZ && camMinZ < maxZ) {
                // get normal
                var normalX = 0.0;
                var normalY = 0.0;
                var normalZ = 0.0;
                var collisionNorm = verts[inds[i]*7 + 5];

                if(collisionNorm == 0) {
                    normalZ = 1.0;
                } else if (collisionNorm == 1) {
                    normalX = 1.0;
                } else if (collisionNorm == 2) {
                    normalY = 1.0;
                } else if (collisionNorm == 3) {
                    normalX = -1.0;
                } else {
                    normalY = -1.0;
                }

                // handle inward corner case (don't slip through a second wall while sliding)
                if (normal[0] == normalX && normal[1] == normalY && normal[2] == normalZ) {
                    continue;
                }

                vec3.set(normal,normalX,normalY,normalZ);
                var dot = vec3.dot(normal,direction);

                // handle outward corner case (don't slip through back walls)
                if (dot > 0) {
                    continue;
                }

                return true;
            }
        }

        return false;
    }

    var havePointerLock = 'pointerLockElement' in document || 'mozPointerLockElement' in document || 'webkitPointerLockElement' in document;

    if ( havePointerLock ) {
        var element = document.getElementById("webglCanvas");
        var pointerlockchange = function ( event ) {
        if ( document.pointerLockElement === element || document.mozPointerLockElement === element || document.webkitPointerLockElement === element ) {
        } else {

        }
      }
      var pointerlockerror = function ( event ) {

      }

      // Hook pointer lock state change events
      document.addEventListener('pointerlockchange', pointerlockchange, false);
      document.addEventListener('mozpointerlockchange', pointerlockchange, false);
      document.addEventListener('webkitpointerlockchange', pointerlockchange, false);
      document.addEventListener('pointerlockerror', pointerlockerror, false);
      document.addEventListener('mozpointerlockerror', pointerlockerror, false);
      document.addEventListener('webkitpointerlockerror', pointerlockerror, false);
      element.addEventListener( 'click', function ( event ) {

        // Ask the browser to lock the pointer
        element.requestPointerLock = element.requestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock;

        if ( /Firefox/i.test( navigator.userAgent ) ) {

          var fullscreenchange = function ( event ) {
            if ( document.fullscreenElement === element || document.mozFullscreenElement === element || document.mozFullScreenElement === element ) {
              document.removeEventListener( 'fullscreenchange', fullscreenchange );
              document.removeEventListener( 'mozfullscreenchange', fullscreenchange );
              element.requestPointerLock();
            }
          }
          document.addEventListener( 'fullscreenchange', fullscreenchange, false );
          document.addEventListener( 'mozfullscreenchange', fullscreenchange, false );
          element.requestFullscreen = element.requestFullscreen || element.mozRequestFullscreen || element.mozRequestFullScreen || element.webkitRequestFullscreen;
          element.requestFullscreen();
        } else {
            element.requestPointerLock();
        }
      }, false);
    } else {
      element.innerHTML = 'Your browser doesn\'t seem to support Pointer Lock API';
    }

    //Function for smooth animations between movements
    //87 - w
    //83 - s
    //65 - a
    //68 - d
    //81 - q
    //69 - e
    //37 - left arrow
    //39 - right arrow
    //38 - up arrow
    //40 - down arrow
    function smoothAnimate() {
      var dx = 0.0;
      var dy = 0.0;
      var moving = false;
      moveLight();
      if(document.activeElement.id == "webglCanvas") {
        if(keyboard[87]) {  //w key
          if(keyboard[16]){
            speedFactor = 2.0;
          } else {
            speedFactor = 1.0;
          }
          moving = true;
          dx += Math.cos(heading[0]) * speedFactor/animationFrames;
          dy += Math.sin(heading[0]) * speedFactor/animationFrames;
        }
        if(keyboard[83]) {  //s key
          if(keyboard[16]){
            speedFactor = 2.0;
          } else {
            speedFactor = 1.0;
          }
          moving = true;
          dx += -Math.cos(heading[0]) * speedFactor/animationFrames;
          dy += -Math.sin(heading[0]) * speedFactor/animationFrames;
        }
        if(keyboard[65]) {  //a key
          if(keyboard[16]){
            speedFactor = 2.0;
          } else {
            speedFactor = 1.0;
          }
          moving = true;
          dx += -Math.sin(heading[0]) * speedFactor/animationFrames;
          dy += Math.cos(heading[0]) * speedFactor/animationFrames;
        }
        if(keyboard[68]) {  //d key
          if(keyboard[16]){
            speedFactor = 2.0;
          } else {
            speedFactor = 1.0;
          }
          moving = true;
          dx += Math.sin(heading[0]) * speedFactor/animationFrames;
          dy += -Math.cos(heading[0]) * speedFactor/animationFrames;
        }
        if(keyboard[81] || keyboard[37]) {  //q key and left arrow
          heading[0] += 1.0/animationFrames;
        }
        if(keyboard[69] || keyboard[39]) {  //e key and right arrow
          heading[0] -= 1.0/animationFrames;
        }
        if(keyboard[38]) { //up arrow
          if(heading[1] >= (Math.PI/3)) {
            heading[1] = (Math.PI/3);
          }
          heading[1] += 0.01;
        }
        if(keyboard[40]) { //down arrow
          if(heading[1] <= -(Math.PI/3)) {
            heading[1] = -(Math.PI/3);
          }
          heading[1] -= 0.01;
        }

        $("#webglCanvas").keydown(movement);
        function movement(event) {
          if(event.key == "l") {
            $("#depth").prop("checked", true);
          }
          if(event.key == "k") {
            $("#depth").prop("checked", false);
          }
        }

        // set direction of travel based on key input
        var direction = vec3.create();
        vec3.set(direction, dx, dy, 0.0);
        var normal = vec3.create();
        vec3.set(normal,0.0,0.0,0.0);

        // check for collision with geometry and set the normal
        var didCollide = detectCollision(pos[0] + dx, pos[1] + dy, pos[2], direction, normal);

        if (moving) {
            if (speedFactor == 2.0) {
                t += Math.PI / 15;
                bob = 0.00750;
            }
            if (speedFactor == 1.0) {
                t += Math.PI / 30;
                bob = 0.0035;
            }
            pos_offset = [-Math.sin(heading[0]) * Math.cos(t) * 2, Math.cos(heading[0]) * Math.cos(t) * 2, Math.sin(2 * t)];
            light_offset = [-Math.sin(heading[0]) * Math.sin(t / 2.0) * 4, Math.cos(heading[0]) * Math.sin(t / 2.0) * 4, -Math.sin(1 * t)]
        } else {
            t = 0;
            light_offset = [light_offset[0] * 0.95, light_offset[1] * 0.95, light_offset[2] * 0.95];
            if (pos[2] > getEyeHeight() + 0.01) { pos[2] -= 0.01; } else if (pos[2] < getEyeHeight() - 0.01) { pos[2] += 0.01;}
        }

        if  (!didCollide && moving) {
              pos[0] += dx + pos_offset[0]*bob;
              pos[1] += dy + pos_offset[1]*bob;
              pos[2] += pos_offset[2]*bob*2;
        } else if(!didCollide) {
              pos[0] += dx;
              pos[1] += dy;
        } else {
            // the new direction is orthogonal to the normal in the XY plane
            var newDir = vec3.create();
            vec3.cross(newDir,normal,direction);
            vec3.cross(newDir,normal,newDir);

            // double check for inner corner case
            if (detectCollision(pos[0] - newDir[0], pos[1] - newDir[1], getEyeHeight(), direction, normal)) {
                // if we're colliding with two walls at once, do nothing
                return;
            }

            pos[0] -= newDir[0];
            pos[1] -= newDir[1];
        }

      }
    }

</script>

<!-- DRAW SHADOW TEXTURE FUNCTION -->
<script>

function drawShadowTexture() {
    gl.bindFramebuffer(gl.FRAMEBUFFER, shadowFBO);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, shadowTexture, 0);
    gl.useProgram(shadowProgram);

    var lightPosVector = vec3.create();
    var lightDirVector = vec3.create();
    vec3.set(lightPosVector, lightPos[0], lightPos[1], lightPos[2]);
    vec3.set(lightDirVector, lightFocus[0], lightFocus[1], lightFocus[2]);

    var vMat = mat4.create();
    mat4.identity(vMat);
    var up = vec3.create();
    vec3.set(up, 0.0, 0.0, 1.0);
    mat4.lookAt(vMat, lightPosVector, lightDirVector, up);
    var vMatLocation = gl.getUniformLocation(shadowProgram, "viewMatrix");
    gl.uniformMatrix4fv(vMatLocation, false, vMat);

    var projMat = mat4.create();
    mat4.perspective(projMat, Math.PI / 3.0, 800.0 / 600.0, 0.1, 100.0); // FOV of light is 60 degrees
    var perspMLocation = gl.getUniformLocation(shadowProgram, "projectionMatrix");
    gl.uniformMatrix4fv(perspMLocation, false, projMat);

    // Only one attribute, position
    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
    var positionLocation = gl.getAttribLocation(shadowProgram, "position");
    gl.enableVertexAttribArray(positionLocation);
    gl.vertexAttribPointer(positionLocation, 3, gl.FLOAT, false, 4*7, 0);
    gl.bindBuffer(gl.ARRAY_BUFFER, null);

    // Draw stuff
    gl.clearColor(0.0, 0.0, 0.0, 0.0);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    gl.enable(gl.DEPTH_TEST);
    gl.cullFace(gl.FRONT);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
    gl.drawElements(gl.TRIANGLES, numIndices, gl.UNSIGNED_SHORT, 0);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
    gl.cullFace(gl.BACK);

    gl.useProgram(null);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, null, 0);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
}

</script>

<!-- DRAW FULL SCREEN QUAD FUNCTION -->
<script>

function drawFSQ() {
    gl.useProgram(fsqProgram);

    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, shadowTexture);
    gl.uniform1i(gl.getUniformLocation(fsqProgram, "texture"), 0);

    // Not accurate near/far plane amounts but this looks good for depth linearization
    gl.uniform1f(gl.getUniformLocation(fsqProgram, "near_plane"), 0.1);
    gl.uniform1f(gl.getUniformLocation(fsqProgram, "far_plane"), 1.0);

    gl.bindBuffer(gl.ARRAY_BUFFER, fsqShape.vertexBuffer);

    var vertPosition = gl.getAttribLocation(fsqProgram, "vert_position");
    gl.enableVertexAttribArray(vertPosition);
    gl.vertexAttribPointer(vertPosition, 3, gl.FLOAT, false, 4 * 5, 0);

    var vertTexCoord = gl.getAttribLocation(fsqProgram, "vert_texCoord");
    gl.enableVertexAttribArray(vertTexCoord);
    gl.vertexAttribPointer(vertTexCoord, 2, gl.FLOAT, false, 4 * 5, 4 * 3);

    gl.bindBuffer(gl.ARRAY_BUFFER, null);

    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, fsqShape.indexBuffer);
    gl.drawElements(gl.TRIANGLES, fsqShape.size, gl.UNSIGNED_SHORT, 0);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

    gl.useProgram(null);
}

</script>

<!-- DRAW SCENE -->
<script>

function drawScene() {
    gl.useProgram(program);

    /** SET UNIFORMS */

    var camPosLocation = gl.getUniformLocation(program, "cameraPosition");
    gl.uniform3f(camPosLocation, pos[0] + 0.5, pos[1] + 0.5, pos[2]);

    var skyRotY = mat4.create();
    var skyRotX = mat4.create();
    var skyRot = mat4.create();
    mat4.fromYRotation(skyRotY, heading[0]);
    mat4.fromXRotation(skyRotX, heading[1]);
    mat4.mul(skyRot, skyRotY, skyRotX);
    gl.uniformMatrix4fv(gl.getUniformLocation(program, "headingRot"), false, skyRot);

    var vMat = mat4.create();
    mat4.identity(vMat);


    var eye = vec3.create();
    var up = vec3.create();
    var look = vec3.create();
    var dir = vec3.create();

    vec3.set(eye, (pos[0] + 0.5), (pos[1] + 0.5), pos[2]);
    vec3.set(up, 0.0, 0.0, 1.0);
    vec3.set(look, Math.cos(heading[0])*Math.cos(heading[1]) + (pos[0] + 0.5), Math.sin(heading[0])*Math.cos(heading[1]) + (pos[1] + 0.5), Math.sin(heading[1]) + pos[2]);
    vec3.set(dir, Math.cos(heading[0])*Math.cos(heading[1]), Math.sin(heading[0])*Math.cos(heading[1]), Math.sin(heading[1]));
    gl.uniform3fv(gl.getUniformLocation(program, "rayDir"), dir);

    var time = (Date.now() - t);
    gl.uniform1f(gl.getUniformLocation(program, "time"), time);



    mat4.lookAt(vMat, eye, look, up);
    var mvMatLocation = gl.getUniformLocation(program, "modelViewMatrix");
    gl.uniformMatrix4fv(mvMatLocation, false, vMat);

    var vMatLocation = gl.getUniformLocation(program, "viewMatrix");
    gl.uniformMatrix4fv(vMatLocation, false, vMat);

    var projMat = mat4.create();
    mat4.perspective(projMat, getFov(), 800.0 / 600.0, 0.1, 100.0);
    var perspMLocation = gl.getUniformLocation(program, "projectionMatrix");
    gl.uniformMatrix4fv(perspMLocation, false, projMat);

    // BEGIN LIGHT MATRICES

    var lightPosVector = vec3.create();
    var lightDirVector = vec3.create();
    vec3.set(lightPosVector, lightPos[0], lightPos[1], lightPos[2]);
    vec3.set(lightDirVector, lightFocus[0], lightFocus[1], lightFocus[2]);

    var lvMat = mat4.create();
    var lprojMat = mat4.create();
    mat4.perspective(projMat, Math.PI/3.0, 800.0 / 600.0, 0.1, 100.0);
    mat4.identity(lvMat);
    mat4.lookAt(lvMat, lightPosVector, lightDirVector, up);

    var lightViewMatrixLocation = gl.getUniformLocation(program, "lightViewMatrix");
    gl.uniformMatrix4fv(lightViewMatrixLocation, false, lvMat);

    var lightProjectionMatrixLocation = gl.getUniformLocation(program, "lightProjectionMatrix");
    gl.uniformMatrix4fv(lightProjectionMatrixLocation, false, projMat);

    // END LIGHT MATRICES

    var normMat = mat3.create();
    mat4.invert(vMat, vMat);
    mat4.transpose(vMat, vMat);
    mat3.fromMat4(normMat, vMat);
    var normMatLocation = gl.getUniformLocation(program, "normalMatrix");
    gl.uniformMatrix3fv(normMatLocation, false, normMat);

    gl.uniform3fv(gl.getUniformLocation(program, "lightPos"), lightPosVector);
    gl.uniform1f(gl.getUniformLocation(program, "fogDensity"), fogDensity);

    /* DONE SETTING UP UNIFORMS */

    /* SET TEXTURES */

    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, wallTexture);
    gl.uniform1i(gl.getUniformLocation(program, "wallTexture"), 0);

    gl.activeTexture(gl.TEXTURE1);
    gl.bindTexture(gl.TEXTURE_2D, floorTexture);
    gl.uniform1i(gl.getUniformLocation(program, "floorTexture"), 1);

    gl.activeTexture(gl.TEXTURE2);
    gl.bindTexture(gl.TEXTURE_2D, wallNormal);
    gl.uniform1i(gl.getUniformLocation(program, "wallNormal"), 2);

    gl.activeTexture(gl.TEXTURE3);
    gl.bindTexture(gl.TEXTURE_2D, floorNormal);
    gl.uniform1i(gl.getUniformLocation(program, "floorNormal"), 3);

    gl.activeTexture(gl.TEXTURE4);
    gl.bindTexture(gl.TEXTURE_CUBE_MAP, skybox);
    gl.uniform1i(gl.getUniformLocation(program, "skyBox"), 4);

    gl.activeTexture(gl.TEXTURE5);
    gl.bindTexture(gl.TEXTURE_2D, shadowTexture);
    gl.uniform1i(gl.getUniformLocation(program, "shadowMap"), 5);

    /* DONE SETTING TEXTURES */

    /* SET UP VERTEX ATTRIBUTES */

    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);

    // Get position (XYZ) attribute to vary per vertex
    var positionLocation = gl.getAttribLocation(program, "position");
    gl.enableVertexAttribArray(positionLocation);
    gl.vertexAttribPointer(positionLocation, 3, gl.FLOAT, false, 4*7, 0);

    // Get UV attribute to vary per vertex
    var uvLocation = gl.getAttribLocation(program, "uv");
    gl.enableVertexAttribArray(uvLocation);
    gl.vertexAttribPointer(uvLocation, 2, gl.FLOAT, false, 4*7, 4*3);

    // Get normDirection attribute to vary per vertex
    var normDirectionLocation = gl.getAttribLocation(program, "normDirection");
    gl.enableVertexAttribArray(normDirectionLocation);
    gl.vertexAttribPointer(normDirectionLocation, 1, gl.FLOAT, false, 4*7, 4*5);

    // Get textureFlag attribute to vary per vertex
    var textureFlagLocation = gl.getAttribLocation(program, "textureFlag");
    gl.enableVertexAttribArray(textureFlagLocation);
    gl.vertexAttribPointer(textureFlagLocation, 1, gl.FLOAT, false, 4 * 7, 4 * 6);

    // Unbind array buffer after setting up attributes
    gl.bindBuffer(gl.ARRAY_BUFFER, null);

    /* DONE SETTING UP VERTEX ATTRIBUTES */

    /* DRAW STUFF */
    gl.clearColor(0.0, 0.0, 0.0, 0.0);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    gl.enable(gl.DEPTH_TEST);

    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
    gl.drawElements(gl.TRIANGLES, numIndices, gl.UNSIGNED_SHORT, 0);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

    gl.useProgram(null);

    /* DONE DRAWING STUFF */

    $("#webglCanvas").keydown(movement);
    function movement(event) {
      event.preventDefault();
      if(event.key == "f") {
        fullScreen();
      }
      if(event.key == "c") {
        cursor = !cursor;
        toggleCursor();
      }
      if(event.key == "r") {
        //window.location.reload(false);
        updateMaze();
      }
      // if(event.key == "l") {
      //   console.log("checked");
      //   $("#depth").checked = true;
      // }
    }
}

</script>

<!-- WEBGL RENDER LOOP CODE HERE -->
<script>
    var wallTexture = null;
    var floorTexture = null;
    var wallNormal = null;
    var floorNormal = null;
    var skybox = null;
    var fogDensity = 0.32;
    var toggle = false;
    var inc = 0;
    var t = Date.now();

    function updateWebGL(time) {
        smoothAnimate();

        drawShadowTexture();
        if ($("#depth").prop('checked')) {
            drawFSQ();
        } else {
        	fogDensity = ($("#fogDensity").prop("value"))/100.0;
            drawScene();
        }

        window.requestAnimationFrame(updateWebGL);
    }

    function startWebGL() {
        // Step 1: Create a LoadQueue object.
        var queue = new createjs.LoadQueue();
        // Step 2: Register the callback function.
        queue.on("complete", function() { runWebGL(queue) }, this);
        // Step 3: List the files you want to load, with their correponding ID.
        queue.loadManifest([
            {
                id: "wall",
                src: "data/wall.jpg"
            },
            {
                id: "floor",
                src: "data/floor.jpg"
            },
            {
                id: "wall_normal",
                src: "data/wall_normal.jpg"
            },
            {
                id: "floor_normal",
                src: "data/floor_normal.jpg"
            },
            {
                id: "sky_up",
                src: "data/skybox/nightsky_up.jpg"
            },
            {
                id: "sky_down",
                src: "data/skybox/nightsky_dn.jpg"
            },
            {
                id: "sky_left",
                src: "data/skybox/nightsky_lf.jpg"
            },
            {
                id: "sky_right",
                src: "data/skybox/nightsky_rt.jpg"
            },
            {
                id: "sky_front",
                src: "data/skybox/nightsky_ft.jpg"
            },
            {
                id: "sky_back",
                src: "data/skybox/nightsky_bk.jpg"
            }
        ]);
    }

    function runWebGL(queue) {
        wallTexture = createTexture(gl, queue.getResult("wall", false));
        floorTexture = createTexture(gl, queue.getResult("floor", false));
        wallNormal = createTexture(gl, queue.getResult("wall_normal", false));
        floorNormal = createTexture(gl, queue.getResult("floor_normal", false));
        skybox = createSkybox(gl,
            queue.getResult("sky_up", false),
            queue.getResult("sky_down", false),
            queue.getResult("sky_left", false),
            queue.getResult("sky_right", false),
            queue.getResult("sky_front", false),
            queue.getResult("sky_back", false)
        );

        window.requestAnimationFrame(updateWebGL);
        window.addEventListener('keydown', keyDown);
        window.addEventListener('keyup', keyUp);
        window.addEventListener('mousemove', mouseMove);
    }

    startWebGL();
</script>

</body>
</html>
